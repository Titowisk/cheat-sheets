## NOLOCK x READPAST
Normalmente transações do tipo Write, bloqueiam outras transações. Se eu tentar ler uma tabela bloqueada não vou conseguir. 
É necessário esperar um rollback ou um commit.

**NOLOCK**: usando o nolock, é possível ler os dados bloqueados e obter os resultados de suas operações. Se ocorrer rollback, isso
significa que meu READ obteve dados que não existem.

**READPAST**: também torna possível fazer leitura em dados bloqueados, mas somente irão ler aqueles que não sofrem alterações
das transações WRITE abertas.

FONTE: ???

## Data Table as Parameters

????????????

Fontes:
- https://stackoverflow.com/questions/13806395/is-it-possible-to-get-table-type-definitions-from-information-schema
- https://codingsight.com/passing-data-table-as-parameter-to-stored-procedures/#:~:text=A%20table%2Dvalued%20parameter%20is,of%20the%20table%2Dvalued%20parameters.

## Query Execution Plan
To read the **SQL Execution Plan correctly**, you should know first that the flow of the execution is starting from the right to the left and from the top to the bottom

The **thickness of the arrow** indicates the amount of data passed between the operators

### Execution Plans types
- The first type is the **Estimated Execution Plan**. It is the plan that is generated by parsing the submitted query as an estimate of how the query will be executed, without being executed.
- The second type is the **Actual Execution Plan**, that is generated by executing the submitted query, displaying the actual steps that followed while executing the query.

Estimated Execution Plan is usefull when the process takes too long to execute.
Actual Execution Plan is the prefered way to analize things.

## Indexes

### Índice de nível único

- Índice principal/primário
- Índice clustering
- Índice secundário

### Caractéristicas
Índices clustering são índices caros, pois exige que a tabela esteja fisicamente organizada o tempo todo.

Índices gerados a partir de atributos de valores únicos são os que apresentam melhor desempenho no acesso, pois
são índices de baixa cardinalidade (cada valor obtém um único registro)

Índices baseados em atributos que sofrem pouca ou nenhuma atualização de seus dados são índices de melhor desempenho 
na manutenção (a estrutura do índice não sofre atualizações, apenas inserções)

### Quando usar

- Existem chaves primárias com garantia de unicidade
- Tabelas grandes e constantemente utilizadas
- Atributos frequentemente utilizados em cláusulas WHERE

### Quando não usar

- Tabelas muito pequenas
- Tabelas que precisam ser acessadas com varreduras (table scan)
- Atributos com domínios de poucos valores distintos

Fonte:
- https://www.sqlshack.com/how-to-analyze-sql-execution-plan-graphical-components/
- https://www.sqlshack.com/sql-server-execution-plans-types/
- BD2 - 01 - Organização, Índices e Catálogos.pdf (semestre 6/)
